<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Flippy Bird (HTML + CSS + JS)</title>
  <style>
    :root {
      --bg: #70c5ce;
      --ground: #ded895;
      --pipe: #2ecc71;
      --pipe-dark: #27ae60;
      --bird: #ffce00;
      --bird-outline: #c88700;
      --ui: #0d1b2a;
      --white: #fff;
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji"; }

    body {
      display: grid;
      place-items: center;
      background: linear-gradient(180deg, var(--bg) 0%, #bfe9f1 100%);
      color: var(--ui);
    }

    .wrap {
      display: grid;
      gap: .75rem;
      place-items: center;
    }

    canvas {
      background: linear-gradient(180deg, var(--bg) 0%, #a1e3f0 55%, var(--ground) 55%, var(--ground) 100%);
      border: 4px solid #00000015;
      border-radius: 16px;
      box-shadow: 0 20px 50px #0000001c, inset 0 4px 12px #ffffff45;
      touch-action: manipulation;
    }

    .hud { display: flex; gap: 1rem; align-items: center; justify-content: center; flex-wrap: wrap; }
    .badge { background: #ffffffcc; padding: .35rem .6rem; border-radius: 999px; font-weight: 700; box-shadow: 0 2px 6px #00000022; }

    .btns { display: flex; gap: .5rem; flex-wrap: wrap; justify-content: center; }
    button {
      border: 0; border-radius: 12px; padding: .6rem .9rem; font-weight: 700; cursor: pointer; background: #111827; color: var(--white);
      box-shadow: 0 6px 14px #00000020; transition: transform .08s ease, box-shadow .2s ease, opacity .2s ease;
    }
    button:hover { transform: translateY(-1px); box-shadow: 0 10px 18px #00000024; }
    button:active { transform: translateY(1px) scale(.98); }
    .help { opacity: .8; font-size: .9rem; }

    @media (max-width: 480px){
      canvas { width: 320px; height: 480px; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="game" width="400" height="600" aria-label="Juego Flippy Bird"></canvas>
    <div class="hud">
      <div class="badge">Puntaje: <span id="score">0</span></div>
      <div class="badge">Récord: <span id="best">0</span></div>
      <div class="badge" id="state">Listo</div>
    </div>
    <div class="btns">
      <button id="play">Jugar / Reiniciar (Espacio)</button>
      <button id="flap">Saltar (Click / Toque)</button>
      <button id="pause">Pausar (P)</button>
    </div>
    <div class="help">Controles: Espacio / Click / Toque para saltar · P para pausar</div>
  </div>

  <script>
    // ---- Configuración ----
    const W = 400, H = 600;
    const GROUND_Y = H * 0.55; // límite visual del pasto

    const GRAVITY = 0.45;       // gravedad
    const FLAP_STRENGTH = -7.5; // impulso hacia arriba
    const TERMINAL_V = 10;      // velocidad máxima en caída
    const PIPE_GAP = 140;       // hueco entre tuberías
    const PIPE_WIDTH = 60;      // ancho de tubería
    const PIPE_SPEED = 2.2;     // velocidad tuberías
    const PIPE_INTERVAL = 95;   // cada N frames se genera una tubería

    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const stateEl = document.getElementById('state');

    const playBtn = document.getElementById('play');
    const flapBtn = document.getElementById('flap');
    const pauseBtn = document.getElementById('pause');

    let best = Number(localStorage.getItem('flippy_best') || 0);
    bestEl.textContent = best;

    // ---- Estado del juego ----
    let bird, pipes, score, frame, running, gameOver, paused;

    function reset(){
      bird = { x: W*0.28, y: H*0.35, r: 14, vy: 0, rot: 0 };
      pipes = []; // cada pipe: { x, topH, passed }
      score = 0; frame = 0; gameOver = false; paused = false; running = true;
      scoreEl.textContent = score; stateEl.textContent = 'Jugando';
    }

    function flap(){
      if (gameOver){ reset(); return; }
      if (!running){ running = true; }
      if (paused) return;
      bird.vy = FLAP_STRENGTH;
    }

    function pauseToggle(){
      if (gameOver) return;
      paused = !paused;
      stateEl.textContent = paused ? 'Pausa' : 'Jugando';
    }

    // ---- Lógica de tuberías ----
    function spawnPipe(){
      const minTop = 40;           // altura mínima del segmento superior
      const maxTop = GROUND_Y - PIPE_GAP - 80; // margen para que el hueco no choque con el suelo
      const topH = Math.floor(minTop + Math.random() * (maxTop - minTop));
      pipes.push({ x: W + 20, topH, passed: false });
    }

    function update(){
      if (!running || paused) return;
      if (gameOver) return;

      frame++;

      // Bird física
      bird.vy = Math.min(bird.vy + GRAVITY, TERMINAL_V);
      bird.y += bird.vy;
      bird.rot = Math.atan2(bird.vy, 8);

      // Generar tuberías
      if (frame % PIPE_INTERVAL === 0){ spawnPipe(); }

      // Mover y limpiar tuberías
      for (let i = pipes.length - 1; i >= 0; i--){
        const p = pipes[i];
        p.x -= PIPE_SPEED;
        if (p.x + PIPE_WIDTH < -40) pipes.splice(i,1);
      }

      // Colisiones y puntaje
      for (const p of pipes){
        const gapTop = p.topH;
        const gapBottom = p.topH + PIPE_GAP;

        // AABB (bird como círculo simplificado)
        const inX = (bird.x + bird.r > p.x) && (bird.x - bird.r < p.x + PIPE_WIDTH);
        const hitTop = inX && (bird.y - bird.r < gapTop);
        const hitBottom = inX && (bird.y + bird.r > gapBottom);

        if (hitTop || hitBottom){
          endGame();
          break;
        }

        // sumar punto cuando pasa el centro de la tubería
        if (!p.passed && p.x + PIPE_WIDTH < bird.x - bird.r){
          p.passed = true;
          score++;
          scoreEl.textContent = score;
        }
      }

      // Suelo y techo
      if (bird.y + bird.r >= H){ endGame(); }
      if (bird.y - bird.r <= 0){ bird.y = bird.r; bird.vy = 0; }
    }

    function endGame(){
      gameOver = true; running = false;
      stateEl.textContent = 'Perdiste';
      if (score > best){
        best = score; localStorage.setItem('flippy_best', String(best));
        bestEl.textContent = best;
      }
    }

    // ---- Render ----
    function draw(){
      // cielo (ya está en el CSS del canvas), aquí dibujamos elementos
      ctx.clearRect(0,0,W,H);

      // colinas suaves
      drawHills();

      // tuberías
      for (const p of pipes){ drawPipe(p); }

      // pájaro
      drawBird(bird);

      // HUD en canvas (sombra de texto)
      ctx.save();
      ctx.font = 'bold 28px system-ui, sans-serif';
      ctx.textAlign = 'center';
      ctx.fillStyle = 'rgba(0,0,0,.25)';
      ctx.fillText(score, W/2 + 2, 70 + 2);
      ctx.fillStyle = '#fff';
      ctx.fillText(score, W/2, 70);
      ctx.restore();

      if (!running && !gameOver){
        drawCenterMsg('Listo · Pulsa Espacio / Click');
      }
      if (paused){ drawCenterMsg('Pausa'); }
      if (gameOver){ drawCenterMsg('Perdiste · Click o Espacio para reiniciar'); }
    }

    function drawCenterMsg(text){
      ctx.save();
      ctx.font = 'bold 20px system-ui, sans-serif';
      ctx.textAlign = 'center';
      ctx.fillStyle = 'rgba(0,0,0,.35)';
      ctx.fillRect(W/2 - 160, H/2 - 40, 320, 80);
      ctx.fillStyle = '#fff';
      ctx.fillText(text, W/2, H/2 + 7);
      ctx.restore();
    }

    function drawBird(b){
      ctx.save();
      ctx.translate(b.x, b.y);
      ctx.rotate(b.rot);
      // cuerpo
      ctx.fillStyle = 'var(--bird)';
      ctx.strokeStyle = 'var(--bird-outline)';
      ctx.lineWidth = 2;
      ctx.beginPath(); ctx.arc(0,0,b.r,0,Math.PI*2); ctx.fill(); ctx.stroke();
      // ala
      ctx.beginPath(); ctx.arc(-4, 0, b.r*0.6, 0, Math.PI*2); ctx.fillStyle = '#ffd84a'; ctx.fill(); ctx.stroke();
      // ojo
      ctx.beginPath(); ctx.arc(6, -4, 3.5, 0, Math.PI*2); ctx.fillStyle = '#fff'; ctx.fill();
      ctx.beginPath(); ctx.arc(7.5, -4, 1.5, 0, Math.PI*2); ctx.fillStyle = '#111'; ctx.fill();
      // pico
      ctx.fillStyle = '#ff9f1a';
      ctx.beginPath(); ctx.moveTo(b.r*0.7, 2); ctx.lineTo(b.r*1.2, -1); ctx.lineTo(b.r*0.7, -4); ctx.closePath(); ctx.fill();
      ctx.restore();
    }

    function drawPipe(p){
      // superior
      ctx.fillStyle = 'var(--pipe)';
      ctx.fillRect(p.x, 0, PIPE_WIDTH, p.topH);
      // inferior
      const bottomY = p.topH + PIPE_GAP;
      ctx.fillRect(p.x, bottomY, PIPE_WIDTH, H - bottomY);
      // bordes oscuros
      ctx.fillStyle = 'var(--pipe-dark)';
      ctx.fillRect(p.x, p.topH - 12, PIPE_WIDTH, 12);
      ctx.fillRect(p.x, bottomY, PIPE_WIDTH, 12);
    }

    function drawHills(){
      // colina 1
      ctx.fillStyle = '#9bd08c';
      ctx.beginPath();
      ctx.arc(80, GROUND_Y+60, 100, Math.PI, 2*Math.PI);
      ctx.fill();
      // colina 2
      ctx.fillStyle = '#7fcf7d';
      ctx.beginPath();
      ctx.arc(220, GROUND_Y+80, 130, Math.PI, 2*Math.PI);
      ctx.fill();
      // colina 3
      ctx.fillStyle = '#6bc16d';
      ctx.beginPath();
      ctx.arc(360, GROUND_Y+70, 120, Math.PI, 2*Math.PI);
      ctx.fill();
    }

    // ---- Bucle principal ----
    function loop(){
      update();
      draw();
      requestAnimationFrame(loop);
    }

    // ---- Entradas ----
    document.addEventListener('keydown', (e)=>{
      if (e.code === 'Space'){ e.preventDefault(); flap(); }
      if (e.code === 'KeyP'){ pauseToggle(); }
    });

    canvas.addEventListener('pointerdown', flap);
    flapBtn.addEventListener('click', flap);
    playBtn.addEventListener('click', ()=>{ reset(); });
    pauseBtn.addEventListener('click', pauseToggle);

    // Inicia detenido hasta que el usuario salte
    running = false; paused = false; gameOver = false;
    bird = { x: W*0.28, y: H*0.35, r: 14, vy: 0, rot: 0 };
    pipes = []; score = 0; frame = 0;
    draw();
    stateEl.textContent = 'Listo';

    requestAnimationFrame(loop);
  </script>
</body>
</html>
